---------
SILEX :
------------------
Sommaire :
INTRO : Qu'est-ce que Silex ?
Etape 0 : Base de notre app : site_mvc (procï¿½dural)
ETAPE 1 : Installation de Silex
ETAPE 2 : Dï¿½marrage et comprï¿½hension
ETAPE 3 : Le routing avec Silex
ETAPE 4 : Virtual Host
ETAPE 5 : HTACCESS : "On retire 'index.php'
ETAPE 6 : Dï¿½marrage de notre application BOUTIQUE
ETAPE 7 : Utilisation des services Silex (Doctine DBAL)
ETAPE 8 : Utilisation des services Silex(Twig)
ETPAE 9 : Utilisation des services Silex (Bootstrap)
ETPAE 10: Ajout des commentaires ï¿½ nos produits (Injection de dï¿½pendance)
ETAPE 11: Le class DAO(design pattern : comment transformer un tableau multidimensionnel composï¿½ d'array, en un tableau dimensionnel composï¿½ d'objet)
ETAPE 12 : Hï¿½ritage TWIG
ETAPE 13: Gestion de la sï¿½curitï¿½ (Connexion)
ETAPE 14: Class MembreDAO et UserProviderInterface
ETAPE 15: Formulaire de connexion
ETAPE 16: Formulaire d'inscription
ETPAE 17: Formulaire de contact
ETAPE 18: BACKOFFICE
ETAPE 19: Rï¿½organisation en Controller
ETAPE 20: Prpï¿½paration de la pise en prod.


---------------------------------
INTRO : Qu'est-ce que Silex ?


  1/ Avantages ï¿½ utiliser un Framework ?

   A/ Choix d'une organisation optimisï¿½e. Il est trï¿½s difficile de conceptualiser soi-mï¿½me une application en objet (un Framework maison). Oï¿½ vont les controller? Les models? Les vues ? Aucune rï¿½ponse n'est parfaite mais chacun ï¿½ sa propre organisation cohï¿½rente...ou pas.


  B/ Focntinnalitï¿½s communes : Un framework permet de rï¿½cupï¿½rer des briques dï¿½jï¿½ existantes.. et les rï¿½cupï¿½rer du site A vers le site B etc.. (Briques : Connexion, inscription, session, commentaires..)


   C/ Services disponibles : Tous les frameworks proposent des services : Routage (Routing), la sï¿½curitï¿½, la gestion du cache etc...
Cela nous permet de nous concentrer et de passer plus de temps au dï¿½veloppement de nos propres fonctionnalitï¿½s.



   2/ Quel choix de Framework ?

  A/Son propre framework maison ?
Trï¿½s formateur !!On peut toujours l'amï¿½liorer et l'utiliser dans des projets persos... par contre : pas de communautï¿½, pas de documentation et c'est difficile de grantir tous les aspects de sï¿½curitï¿½.



  B/Framework du marchï¿½ :

-Framework Fullstack (Zend, Symfony, Cake) : Beaucoup de services disponibles, grosses communautï¿½s, mais un dï¿½ploiement trï¿½s lourd et une architecture IMPOSEE.

-Mini Framework (Laravel et Silex) : Proposent des services ï¿½ la carte et une architecture plus souple.

 A/ Silex est un framework developpï¿½ par les ï¿½quipes SensioLabs, qui sont les crï¿½ateurs de Symfony. Il repose sur les mï¿½mes composants.



 B/On dit que Silex est un mini-framework , parfait pour l'apprentissage, et la comprï¿½hension de la logique Framework. Parfait ï¿½galement pour dï¿½velopper des applications rapidement et premiï¿½re ï¿½tape intï¿½ressante dans l'apprentissage de Symfony.






  B/Framework du marchï¿½ : FullStack






----------------------------------------------------
Etapae 0 : Base de notre app : site_mvc (procï¿½dural)
----------------------------------------------------
Pour commencer la comprï¿½hension de Silex, nous allons partir sur la base d'un morceau de site en procï¿½dural et en MVC afin d'avancer ï¿½tape par ï¿½tape :


silex/site_mvc/
    - css/(copier de votre ancien site procï¿½dural)
    - photo/(copier de votre ancien site procï¿½dural)
    - index.php (vide)
    - model.php(vide)
    - view.php (vide)




Etape 1 : Installation de Silex



Sommaire:

1/Installation de composer
2/Crï¿½ation du dossier BOUTIQUE
3/ Commande pour tï¿½lï¿½charger les composants de Silex
3.Bis : Autre technique pour tï¿½lï¿½charger les composants de silex
4/ tour d'horizon des composants.
-------------------------



1/Installation de Composer

Composer est outil de gestion des dï¿½pendances. Il permet d'installer des services (composants, dï¿½pendances) et est reliï¿½ ï¿½ un fichier composer.json.

-->Tï¿½lï¿½charger composer
--> Installer composer (en prï¿½cisant php.exe)


2/ creation du dossier silex/BOUTIQUE/

3/ cOMMANDE POUR T2L2CHARGER LES COMPOSANTS DE SILEX /
-> on se place dans le dossier BOUTIQUE/
-> Maj + clic droit > "Ouvrir la fenetre de commande ici"


<cmd>

composer require silex/silex "~2.0"
  <code>
    {
     "require": {
                "silex/silex": "~2.0"
                }
        }
      <cmd>
  composer update


4/Les composants :

Le dossier vendor correspond au coeur de notre framework. Il contient tous les composants rï¿½cupï¿½rï¿½s de Silex/Symfony, sur lesquels nous n'intervidendrons jamais !!!

3.bis

----------------------------
ETAPE 2 : Dï¿½marrage et Comprï¿½hension
------------------------------

Sommaire :
1/Crï¿½ation du rï¿½pertoire Web
2/Crï¿½ation du fichier index.php


1/repertoire web

-> a la racine de notre application BOUTIQUE/web/
-> Ce dossier constitue notre repertoire web, cela signifie qu'il va contenir tout ce qui est visble et accessible pour l'internaute (index.php, photos, img, fonts, js, css...)


2/ creer web/index.php

->d'abord on require l'autoload qui se chargera de require tous les fichiers dont on aura besoin.PRATIQUE !



-> On instancie la classe Application : L'objet $app va reprï¿½senter notre application et nous donne accï¿½s ï¿½ toutes les fonctionnalitï¿½s de Silex.

-> Mï¿½thode run() : Lancement de l'application.



---------------------------------
ETAPE 3 : Le routing sur Silex
--------------------------------

Sommaire :

1/ Route Hello World
2/ Route Hello {$name}
3/ La fonction Get de notre application
4/ Arguments
5/ fonction escape()
-----------------------



1/ Route Hello World


 -> $app -> get() est la fonction qui nous permet de crï¿½er une nouvelle route. Chaque route est une action dans notre application. Ensuite nous rangerons toutes nos actions dans des controllers, pour optimiser notre organisation.


2/Route Hello {$name}
  ->Creation de la route /hello/{name}
->Test : localhost/silex/BOUTIQUE/web/index.php/hello/Yannick


3/La fonction Get()
-> A chaque nouvelle fonctionnalitï¿½, on va utiliser la fonction get de $app, qui nous crï¿½e une nouvelle route. En plus de get, il existe post() et match(). Nous les verrons plus tard.


4/Arguments:
-> le premier argument est la nom de la route. Les paramï¿½trres contenus dans les URL sont alors dï¿½clarï¿½ en {]
-> le second argument function{} est ce que l'on appelle une "closure" ou une "fonction anonyme". Elle signifie que ce qui va suivre sera executï¿½. Une fonction dans une fontion finalement. Elle peut recevoir les paramï¿½trres dynamiques de notre URL (ex: function ($name)).

5/ La mï¿½thode escape()
 -> La fonction escape() permet simplement d'afficher le paramï¿½tre contenu dans la route.La mï¿½thode escape() permet d'ï¿½viter les injections SQL dans votre URL.

-----------------------
ETAPE 4 : VIRTUAL HOST
------------------------

Sommaire :

1/ Modifier le fichier vhost (apache)
2/ Modifier le fichier conf (apache)
3/Modifier le fichier host (system32)



1/mODIFICATION DU FICHIER VHOST /
 >c:\xampp\apache\conf\extra\httpd-vhosts.conf

2/ Modification du fichier conf :
> c:\xampp\apache\conf\httpd.conf

3/ Modification du fichier Hosts dans system 32
> c:\windows\system32\drivers\etc\hosts





-------------------------------------------
ETAPE 5 : HTACCESS POUR RETIRER INDEX.PHP :
-------------------------------------------

 -> Crï¿½er dans le dossier web de notre application, test.txt


 <code>
    <IfModule mod_rewrite.c>

   Options -MultivViews


  RewriteEngine On

  RewriteCond %{REQUEST_FILENAME} !-f

  RewriteRule ^ index.php [QSA,L]

  </IfModule>


 -> Enregistrer le fichier avec l'extension .htaccess.
Pour ce faire, selectionner tous les formats



Test ï¿½ effectuer : www.boutique.dev/hello/yakine





--------------------------------------
ETAPE 6 : DEMARRAGE DE L'APPLICATION :
--------------------------------------

Sommaire :
1/ Crï¿½ation des dossiers

2/ Rï¿½cupï¿½rer les fichiers (de notre base site_mvc)

3/ Crï¿½ation du fichier de routes

4/ Rï¿½-ï¿½criture de index.php

--------------------------------------

1/ Crï¿½ation des dossiers :

 BOUTIQUE/

  web/      (dï¿½jï¿½ crï¿½ï¿½)

  vendor/ (dï¿½jï¿½ crï¿½e)

    app/     (config de l'application)

  db/     (script de creation de la bdd)

   src/     (fichiers sources de notre application)

 views/     (les vues de notre application)

2/ Rï¿½cupï¿½rer les fichiers (de notre base site_mvc)

Dans un premier temps on va gï¿½rer l'affichage de nos produits

->model.php ï¿½ copier/coller dans src/
->view.php ï¿½ copier/coller dans views/
->css/photo/ ï¿½ copier/coller dans web/


3/ Crï¿½er un fichier de route qui va contenir toutes nos routes
 -> app/routes.php
-> On re-crï¿½e ma route '/'(la home), dans laquelle on va rï¿½cupï¿½rer les infos de tous nos produits (grï¿½ce ï¿½ model.php et sa fonction afficheAll()) et on les affiche via le concept render() (temporisation puis affichage)


4/Rï¿½-ï¿½criture de index.php

 -> A ce stade, nous avons plus besoin des routes ï¿½crutes dans index.php, mais on a besoin de require notre fichier de routes (routes.php)
 -> O ajoute le mode debug car nous sommes en dev.

Test: www.boutique.dev
<<<<<<< HEAD
A ce stade, npus devrions avoir la boutique qui s'affiche sur la home de notre nouveau site.
en revanche, nous sommes en procï¿½dural... Il va donc falloir ajouter une couche OBJET.
=======
A ce stade, npus devrions avoir la boutique qui s'affiche sur la home de notre nouveau site. 
en revanche, nous sommes en procédural... Il va donc falloir ajouter une couche OBJET. 



ETAPE 7 : UTILISATION DES SERVICES SILEX: 
Doctrine BDAL + modélisation objet 


Sommaire : 
1/Création de la classe Produit dans src/Entity 
2/Remplacement de PDO par Doctrine DBAL 
3/Créer le dossier DAO (Data Access Object)
4/Ajouter le fichier ProduitDAO.php 
5/Mise à jour de l'application via composer
6/Création du fichier app.php dans app/ 
7/creation du fichier prod.php dans app/config 
8/creation du fichier dev.php dans app/config/
9/Modification des routes
10/Modification de la vue 
11/Modification de l'index.php




1/ Création de la class Produit dans src/Entity 
->Creation de la classe Produit dans src/Entity/Produit.php 
->cette classe va servir de plan de fabrication d'un objet Produit. Un prototype. Il contient toutes les propriétés de l'entité produit (private) 
et tous les getter/setters. On dit que cette classe est un POPO (PLAIN OLD PHP OBJECT)


2/ Remplacement de PDO par Doctrine DBAL 
-> Doctrine DBAL (DATABASE Abstract Layer) : Fait la même chose que PDO mais améliore le système de requête. Ce service de Silex,, nous permet également une connexion compatible avec tout type de gestion de BDD.
Il nous récupère la connexion dans un SINGLETON sans qu'on ait besoin de le faire nous-même. 



3/ Création un dossier DAO dans src/

->DAO : DATA ACCESS OBJECT : DAO est un design pattern qui répond à la questioin ; Comment récupérer des infos depuis la base données non pas sous forme d'array, mais sous forme d'objets ? ==> voire la méthode (buildProduit())


4/Création du fichier produit DAO.php dans src/DAO/

-> Ce fichir correspond à notre MODEL PRODUIT. C'est lui qui va gérer toutes les requetes auprès de la table produit, et nous renvoyer les résultats sous forme d'objets. 

-> On a récupéré la connexion à la base de données grâce à Doctrine\DBAL\Connextion. 
->On stocke cette connexion dans la propriété private $db. 
->Chauqe requete sur la table Produit sera representee par une fonction. (findAll, findById, findAllByCategorie,etc...)
->Pour chacune de ses requestes quand cela est possible on va transformer les relustas d'array en objets grace à a la méthode buildProduit()).

===>DAO est un design pattern qui permet de modéliser sous forme d'objet (ENTITY) les resultats d'une requete.

Mise à jour de notre notre application 

 {
        "require": {
            "silex/silex": "~2.0",
            "doctrine/dbal": "2.5"
        }
        "autoload": {
            "psr-4" : {"BOUTIQUE\\": "src"}
        }
    }


<cmd>
composer update 

-> Cette commande a fait : 
- Récuperer les composants Doctrine DBAL
-Mise à jour l'autoload selon la norme PSR-4 (les noms des namespaces correspondent à des noms des dossiers) 


6/creation du fichier app.php dans le dossier app/ 
 ->Ce fichier représente les paramètres de notre application. Quand vous déplacerez votre application d'un server à un autre en théorie vous ne dervez modifier que ce fichier là... A l'insatr de init.inc.php dans notre procédural. 
 -> Les deux premieres lignes (use ErrorHandler et ExceptionHandler) permettent à notre application de gérer les erreurs sous forme d'Exception. 
Les composants Symfony prennent la main sur la gestion des erreurs PHP.


 -> Ensuite on enregistre le fournisseur de service associé à Doctrine DBAL. 
A faire pour tous les services utilisés.

-> Enfin on déclare/enregistre notre class ProduitDAO dans notre $app['dao.produit']. Cela nous permettra de rendre plus simple l'utilisation de notre instance de la classe ProduitDAO. 
$app['db'] représente par ailleurs notre connexion à la BDD grace à Doctrine DBAL. 


7/Création du fichier prod.php dans app/config 
-> Cefichier contient toutes les infos de connexion à la bdd. 

8/Création du fichier dev.php dans app/config
->Ce fichier contient les infos relatives à la phase de dev. 



9/modification du fichier routes.php 




10/Modification de view.php 
-> On remplace les arrays par l'utilisation des getter : 
ARRAY : <?= $pdt['titre'] ?>
OBJET : <?= $pdt->getTitre() ?>
TWIG : {{pdt.titre}}


11/Modification du fichier index.php 

->On met en commentaire $app['debug'] = true, puisque nous l'avons mis dans dev.php 
->On ajoute les require de app.php et dev.php avant le require de routes.php 

->A ce stade, notre home doit afficher tous les produits, et le menu des categories. 
===> Cette étape nous a permis d'introduire une modélisation objet (propre à silex : DAO, routing..) 
===> Nous avons beaucoup travaillé la partie MODELS (DAO) et CONTROLLER (Routes.php), à l'étape suivante nous allons inétresser à la partie VIEWS avec TWIIG

--------------------------------------------------------------------------
ETAPE 8: UTILISATION DES SERVICES SILEX(Twig)
(Ajout de l'utilisation de la fonction render)
--------------------------------------------------------------------------

Sommaire : 

1/ Intro 
2/Modification composer.json 
3/Mise à jour via comoposer 
4/Modification de app.php (enregistrement des nouveaux services)
5/Modification des fichiers view.php, produit.php en Twig 
6/Fonction render(): modélisation des routes. 
------------------------------

1/ Intro : 
-> Il existe plusieurs moteurs template : Liquid, TPL, smarty, Blade, Twig. 
-> De manière générale, un moteur de template permet de simplifier l'insertion de variables et de boucles PHP dans des blocs HTML.(idée des formes contractées) 

-> TWIG à l'avantage de proposer un systèùe d'héritage. En d'autres termes, des morceaux d'HTML vont hériter d'autres morceaux d'HTML. Exemple: Le formulaire d'inscription hérite du template général de la page. 

2/Modification du JSON 


3/Mise à jour via composer
<cmd>
composer update 


4/Modification de app.php 

->enregistrement aux services Twig. 
->L'enregistrement nécessite qu'on passe en argument le chemin de nos vues

<code>
 $app->register (new Silex/Provider/TwigServiceProvider(), array(
'twig.path' => __DIR__.'/../views'
)); 


5/Modifications de nos vues : 
-> view.php ==> index.html.twig
->produit.php===> produit.html.twig

6/ Modification des routes 
->Ajout de la méthode render() 
-> La méthode render est globalement commune à toutes les applications OBJET/MVC bien modélisée. Elle va rendre une vue, et embarquer tous les paramètres dynamiques nécessaires à cette vue. 

->Les paramètres embarqués, le sont toujours sous forme d'un array. 

-----> A ce stade, notre home doit s'afficher. Test: www.boutique.dev. 
------> En savoir plus sur Twig

---------------------------------------------------------------
ETAPE 9 : UTILISATION DES SERVICES SILEX (Assets)
----------------------------------------------------------------

Sommaire : 

1/Modification de composer.json
2/mise à jour des services 
3/Modification de app.php
4/Modification des vues (chemins css/js/image)
5/Modification des vues (liens)
------------------------------

<code>
    {
        "require": {
            "silex/silex": "~2.0",
            "doctrine/dbal": "2.5",
            "twig/twig": "~1.28",
            "symfony/asset": "~2.8|3.0.*"
        },
        "autoload": {
            "psr-4" : {"BOUTIQUE\\": "src"}
        }
    }    

    <cmd>
    composer update
    composer require symfony/twig-bridge


4/Modification des chemins css/js/photo
->On modifie tous les chemins des ressources de cette manière 
src="photo/{{pdt.photo]}}"
href="../css/styles.css"

src="{{ asset('photo/'~pdt.photo) }}"
href={{ asset('/css/styles.css') }}"
href="../bootstrap/js/bootstrap.min.js"


src="{{ asset('photo/' ~ pdt.photo}}
href="{{ asset('css/style.css') }}"
href="../bootstrap/js/bootstrap.min.js"

5/ Modification des vues et des routes : 

-> Liens : 
-href="/profil/"
-href="/boutique/{categorie.categorie}}"
-href="/produit/[[pdt.id_produit}}"

-href="{{ path('profil') }}" 
-href="{{ path('boutique',{'categorie': categorie.categorie} ) }}"
-href="{{ path('produit', {'id' : pdt.id_produit} ) }}"

-> Chaque route va avoir un nom : 

$app-> get('/profil/',


|) -> bind('profil'); 


$app->get('/boutique/{categorie}'

)->bind('boutique'); 


$app->get('/produit/{id}'

)->bind('produit'); 



-> grâce au service assets de Silex, tous nos liens et chemis vont être dynamisés et absolues. 

->Pour cela on utilise asset() (ressources) et path() (lien). 
Concernant path() pour que cela fonctionne, il faut que toutes nos routes aient un nom. 


---------------------------------------
ETAPE 12 : Héritage Twig :
----------------------------------------

Sommaire : 

1/Créer le fichier layout.html.twig (structure de page) dans views/
2/Modifier vues 


1/Création du fichier layout.html.twig 
-> On y met toute la structure d'une page 

        <!DOCTYPE html>
         ...
        <section>
         ...
         ...
        </section>
        </html>




2/ Modifier les vues : 

<code> 
  {% extends 'layout.html.twig' %}







--------------------------------------
ETAPE 17 : FORMULAIRE DE CONTACT
--------------------------------------
Sommaire: 

1/ Créer la route(render)
-> Creation de la route /contact./
-> Lorqu'on intéragit avec un formulaire en silex, et si on utilise toutes les fonctionnalités de silex, il faut  utiliser le composant Request qui gère la soumission du formulaire. 
La fonction anonyme function() attend donc un objet de la classe Request. 
->Le composant Request de HttpFoundation doit être USE en haut du fichier: 
<code>
use Symfony\Component\HttpFoundation\Request; 
->Cette route doit traiter des infos en get (nom de la route) et en post (info du formulaire), la fonction est donc match (post+get) et non pas get(). 



2/Faire le fichier contact.html.twig
-> On ne crée pas le formulaire directement en HTML, on prépare simplement la page car le formulaire sera crée à l'étape suivante, via la class abstraite AbstractType qui permet de créer des classes gérants la construction de nos fomrulaires. 
Cette démarche est nouvelle mais très pratique par la suite. 
3/Creer ContactType(la classe qui va nous construire le formulaire)
->On crée un fichier ContactType; dans le sous-dossier Type dans le dossier Form
->Cette classe va nous permettre de définir ce qu'est notre formulaire de contact. Elle hérite de la classe abstraite AbstractType. 
->La méthode FormBuilder va nous permettre de construire un formulaire, et va attendre en argument un objet de l'interface FormBuilderInterface.
->La méthode Build va nous permettre de construire chaque champs un par un avec des options possibles pour chacun : Les contraintes, les classes, les attributs etc... etc...
->Pour que l'ensemble fonctionne  nous avons besoin de USE beaucoup de composants : 
<code>
  use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\Form\Extension\Core\Type\TextType;
use Symfony\Component\Form\Extension\Core\Type\EmailType;
use Symfony\Component\Form\Extension\Core\Type\ChoiceType;
use Symfony\Component\Form\Extension\Core\Type\TextareaType;
use Symfony\Component\Validator\Constraints as Assert;
use Symfony\Component\Validator\Constraints\NotBlank;





-> mise à jour de l'app (json + composer)

{
    "require": {
        "silex/silex": "~2.0",
        "doctrine/dbal": "2.5",
        "twig/twig": "~1.28",
        "symfony/asset": "~2.8|3.0.*",
        "symfony/twig-bridge": "^3.3",
        "symfony/form": "~2.8|3.0.*",
        "symfony/translation": "~2.8|3.0.*",
   "symfony/config": "~2.8|3.0.*",
   "symfony/validator": "^3.2"
    },
    "autoload": {
        "psr-4" : {"BOUTIQUE\\": "src"}
    }
}

<cmd>
 composer update

->Mise à jour de l'app (JSON + composer)
->enregistrement service form
->Form/Type/ContactType



Enregistrement de nouveaux services (json + composer + app.php)


5/Modifier la route (récupération du formulaire]
-> La fonction create () de $app['form.factory] va construire et récupéerer notre formulaire, en lui précisant le type de formulaire à récupérer. 
->HandleRequest($request) de notre fomulaire va gérer les infos récupérées. 
->CreateView()de notre formulaire va créer la partie visuel du formulaire, et c'est cela que nous allons envoyer à la vue. 

6/Modifier la vue.contact.html.twig
-> Twig simplifie énormément la gestion de l'affichage du formulaire, l'affichage des données dans le formulaire et l'affichage des messages d'erreurs : 
<code>
{% if contactForm %}
 {{ form_start(contactForm)}}
    <label> Prénom : </label>
{{ form_errors(contactForm.prenom}}
{{ form_widget(contactForm.prenom}}
....
....

{{form_end (contactForm)}}
{%endif}


7/Modifier la route (traitement de l'email)
   ->Notre contactForm contient une méthode IsSubmitted() et isValid() qui nous permettent de savoir si le formulaire est activé et validé. 
-> Ce système remplace un nombre incalculable de ligne PHP en mode procédural :) :) 


======> A ce stade le formulaire www.boutique.dev/contact doit s'afficher, et nous retourner un print_r() avec tous les infos en post. 

======>Il suffirait d'ajouter des traitements dans notre route pour que le fonctionnement soit complet.


---------------------------------------
Etape 19: Réorganisation en Controller
---------------------------------------

1/Création de deux controller : BaseController et ProduitController. 
2/Création des fonctions dans notre controller
3/Modification des routes 
4/Modification des fonctions dans nos controllers.



->Dans chaque controller, on autant d(action (fonction) que d'affichage prévue. Un affichage==une fonction

2/On crée des fonctions pour chaque controller en fonction des affichages et des actions qu'ils doivent gérer. 

->Exemple: ProduitController->produitAction($id)
->exemple: ProduitController->boutiqueAction($categorie)

3/Les routes ne contiennent plus de fonctions anonyme et donc plus de traitement; mais appellent simplement la fonction qu'il va falloir executer. 

4/Touts les traitements qui étaient présents dans les routes, sont maintenant encapsulés dans les fonctions des Controller. 	


----------------------------------------------
ETAPE18: BACKOFFICE 
--------------------------------------------
Sommaire : 

1/Creer un controller BackOfficeController 
2/Creer la route get ('backoffice/produit') dont le nom est bo_produit
3/Créer la fonction produitAction dans BackOfficeController et gérer toute la fonction 
4/Créer la vue backoffice_produit.html.twig qui va afficher tous les produits sous forme d'un tableau 
5/Créer la route match('backoffice/produit/{id}/add') dont le nom est bo_produit_add
6/Creer la fonction addProduitAction() et gérer l'affichage de la page d'ajout.
7/Créer ProduitType pour créer le formulaire d'ajout de produit
8/Modifier la fonction addProduitAction() pour qu'elle affiche le formualaire.





---------------







contact 


re-organisation en controller 



backoffice : ajouter un produit / Modifier / Supprimer
Connexion : DAO, Modification de la BDD : username/password, Entity Membre, MembreType



















































































































Exercice 
boutique/tshirt
boutique/chemise
boutique/pull

1/Créer la nouvelle route dans routes.php 
2/Créer la requete dans une fonction findByCategorie($categorie) dans ProduitDAO
3/Récupérer les infos de la fonction dans la route dans une varibale $produits 
...
5/Affiche la views view.php 
6/Modifier les liens des categories vers boutique/nom_de_la_categorie

