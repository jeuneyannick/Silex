---------
SILEX :
------------------
Sommaire :
INTRO : Qu'est-ce que Silex ?
Etape 0 : Base de notre app : site_mvc (procï¿½dural)
ETAPE 1 : Installation de Silex
ETAPE 2 : Dï¿½marrage et comprï¿½hension
ETAPE 3 : Le routing avec Silex
ETAPE 4 : Virtual Host
ETAPE 5 : HTACCESS : "On retire 'index.php'
ETAPE 6 : Dï¿½marrage de notre application BOUTIQUE
ETAPE 7 : Utilisation des services Silex (Doctine DBAL)
ETAPE 8 : Utilisation des services Silex(Twig)
ETPAE 9 : Utilisation des services Silex (Bootstrap)
ETPAE 10: Ajout des commentaires ï¿½ nos produits (Injection de dï¿½pendance)
ETAPE 11: Le class DAO(design pattern : comment transformer un tableau multidimensionnel composï¿½ d'array, en un tableau dimensionnel composï¿½ d'objet)
ETAPE 12 : Hï¿½ritage TWIG
ETAPE 13: Gestion de la sï¿½curitï¿½ (Connexion)
ETAPE 14: Class MembreDAO et UserProviderInterface
ETAPE 15: Formulaire de connexion
ETAPE 16: Formulaire d'inscription
ETPAE 17: Formulaire de contact
ETAPE 18: BACKOFFICE
ETAPE 19: Rï¿½organisation en Controller
ETAPE 20: Prpï¿½paration de la pise en prod.


---------------------------------
INTRO : Qu'est-ce que Silex ?


  1/ Avantages ï¿½ utiliser un Framework ?

   A/ Choix d'une organisation optimisï¿½e. Il est trï¿½s difficile de conceptualiser soi-mï¿½me une application en objet (un Framework maison). Oï¿½ vont les controller? Les models? Les vues ? Aucune rï¿½ponse n'est parfaite mais chacun ï¿½ sa propre organisation cohï¿½rente...ou pas.


  B/ Focntinnalitï¿½s communes : Un framework permet de rï¿½cupï¿½rer des briques dï¿½jï¿½ existantes.. et les rï¿½cupï¿½rer du site A vers le site B etc.. (Briques : Connexion, inscription, session, commentaires..)


   C/ Services disponibles : Tous les frameworks proposent des services : Routage (Routing), la sï¿½curitï¿½, la gestion du cache etc...
Cela nous permet de nous concentrer et de passer plus de temps au dï¿½veloppement de nos propres fonctionnalitï¿½s.



   2/ Quel choix de Framework ?

  A/Son propre framework maison ?
Trï¿½s formateur !!On peut toujours l'amï¿½liorer et l'utiliser dans des projets persos... par contre : pas de communautï¿½, pas de documentation et c'est difficile de grantir tous les aspects de sï¿½curitï¿½.



  B/Framework du marchï¿½ :

-Framework Fullstack (Zend, Symfony, Cake) : Beaucoup de services disponibles, grosses communautï¿½s, mais un dï¿½ploiement trï¿½s lourd et une architecture IMPOSEE.

-Mini Framework (Laravel et Silex) : Proposent des services ï¿½ la carte et une architecture plus souple.

 A/ Silex est un framework developpï¿½ par les ï¿½quipes SensioLabs, qui sont les crï¿½ateurs de Symfony. Il repose sur les mï¿½mes composants.



 B/On dit que Silex est un mini-framework , parfait pour l'apprentissage, et la comprï¿½hension de la logique Framework. Parfait ï¿½galement pour dï¿½velopper des applications rapidement et premiï¿½re ï¿½tape intï¿½ressante dans l'apprentissage de Symfony.






  B/Framework du marchï¿½ : FullStack






----------------------------------------------------
Etapae 0 : Base de notre app : site_mvc (procï¿½dural)
----------------------------------------------------
Pour commencer la comprï¿½hension de Silex, nous allons partir sur la base d'un morceau de site en procï¿½dural et en MVC afin d'avancer ï¿½tape par ï¿½tape :


silex/site_mvc/
    - css/(copier de votre ancien site procï¿½dural)
    - photo/(copier de votre ancien site procï¿½dural)
    - index.php (vide)
    - model.php(vide)
    - view.php (vide)




Etape 1 : Installation de Silex



Sommaire:

1/Installation de composer
2/Crï¿½ation du dossier BOUTIQUE
3/ Commande pour tï¿½lï¿½charger les composants de Silex
3.Bis : Autre technique pour tï¿½lï¿½charger les composants de silex
4/ tour d'horizon des composants.
-------------------------



1/Installation de Composer

Composer est outil de gestion des dï¿½pendances. Il permet d'installer des services (composants, dï¿½pendances) et est reliï¿½ ï¿½ un fichier composer.json.

-->Tï¿½lï¿½charger composer
--> Installer composer (en prï¿½cisant php.exe)


2/ creation du dossier silex/BOUTIQUE/

3/ cOMMANDE POUR T2L2CHARGER LES COMPOSANTS DE SILEX /
-> on se place dans le dossier BOUTIQUE/
-> Maj + clic droit > "Ouvrir la fenetre de commande ici"


<cmd>

composer require silex/silex "~2.0"
  <code>
    {
     "require": {
                "silex/silex": "~2.0"
                }
        }
      <cmd>
  composer update


4/Les composants :

Le dossier vendor correspond au coeur de notre framework. Il contient tous les composants rï¿½cupï¿½rï¿½s de Silex/Symfony, sur lesquels nous n'intervidendrons jamais !!!

3.bis

----------------------------
ETAPE 2 : Dï¿½marrage et Comprï¿½hension
------------------------------

Sommaire :
1/Crï¿½ation du rï¿½pertoire Web
2/Crï¿½ation du fichier index.php


1/repertoire web

-> a la racine de notre application BOUTIQUE/web/
-> Ce dossier constitue notre repertoire web, cela signifie qu'il va contenir tout ce qui est visble et accessible pour l'internaute (index.php, photos, img, fonts, js, css...)


2/ creer web/index.php

->d'abord on require l'autoload qui se chargera de require tous les fichiers dont on aura besoin.PRATIQUE !



-> On instancie la classe Application : L'objet $app va reprï¿½senter notre application et nous donne accï¿½s ï¿½ toutes les fonctionnalitï¿½s de Silex.

-> Mï¿½thode run() : Lancement de l'application.



---------------------------------
ETAPE 3 : Le routing sur Silex
--------------------------------

Sommaire :

1/ Route Hello World
2/ Route Hello {$name}
3/ La fonction Get de notre application
4/ Arguments
5/ fonction escape()
-----------------------



1/ Route Hello World


 -> $app -> get() est la fonction qui nous permet de crï¿½er une nouvelle route. Chaque route est une action dans notre application. Ensuite nous rangerons toutes nos actions dans des controllers, pour optimiser notre organisation.


2/Route Hello {$name}
  ->Creation de la route /hello/{name}
->Test : localhost/silex/BOUTIQUE/web/index.php/hello/Yannick


3/La fonction Get()
-> A chaque nouvelle fonctionnalitï¿½, on va utiliser la fonction get de $app, qui nous crï¿½e une nouvelle route. En plus de get, il existe post() et match(). Nous les verrons plus tard.


4/Arguments:
-> le premier argument est la nom de la route. Les paramï¿½trres contenus dans les URL sont alors dï¿½clarï¿½ en {]
-> le second argument function{} est ce que l'on appelle une "closure" ou une "fonction anonyme". Elle signifie que ce qui va suivre sera executï¿½. Une fonction dans une fontion finalement. Elle peut recevoir les paramï¿½trres dynamiques de notre URL (ex: function ($name)).

5/ La mï¿½thode escape()
 -> La fonction escape() permet simplement d'afficher le paramï¿½tre contenu dans la route.La mï¿½thode escape() permet d'ï¿½viter les injections SQL dans votre URL.

-----------------------
ETAPE 4 : VIRTUAL HOST
------------------------

Sommaire :

1/ Modifier le fichier vhost (apache)
2/ Modifier le fichier conf (apache)
3/Modifier le fichier host (system32)



1/mODIFICATION DU FICHIER VHOST /
 >c:\xampp\apache\conf\extra\httpd-vhosts.conf

2/ Modification du fichier conf :
> c:\xampp\apache\conf\httpd.conf

3/ Modification du fichier Hosts dans system 32
> c:\windows\system32\drivers\etc\hosts





-------------------------------------------
ETAPE 5 : HTACCESS POUR RETIRER INDEX.PHP :
-------------------------------------------

 -> Crï¿½er dans le dossier web de notre application, test.txt


 <code>
    <IfModule mod_rewrite.c>

   Options -MultivViews


  RewriteEngine On

  RewriteCond %{REQUEST_FILENAME} !-f

  RewriteRule ^ index.php [QSA,L]

  </IfModule>


 -> Enregistrer le fichier avec l'extension .htaccess.
Pour ce faire, selectionner tous les formats



Test ï¿½ effectuer : www.boutique.dev/hello/yakine





--------------------------------------
ETAPE 6 : DEMARRAGE DE L'APPLICATION :
--------------------------------------

Sommaire :
1/ Crï¿½ation des dossiers

2/ Rï¿½cupï¿½rer les fichiers (de notre base site_mvc)

3/ Crï¿½ation du fichier de routes

4/ Rï¿½-ï¿½criture de index.php

--------------------------------------

1/ Crï¿½ation des dossiers :

 BOUTIQUE/

  web/      (dï¿½jï¿½ crï¿½ï¿½)

  vendor/ (dï¿½jï¿½ crï¿½e)

    app/     (config de l'application)

  db/     (script de creation de la bdd)

   src/     (fichiers sources de notre application)

 views/     (les vues de notre application)

2/ Rï¿½cupï¿½rer les fichiers (de notre base site_mvc)

Dans un premier temps on va gï¿½rer l'affichage de nos produits

->model.php ï¿½ copier/coller dans src/
->view.php ï¿½ copier/coller dans views/
->css/photo/ ï¿½ copier/coller dans web/


3/ Crï¿½er un fichier de route qui va contenir toutes nos routes
 -> app/routes.php
-> On re-crï¿½e ma route '/'(la home), dans laquelle on va rï¿½cupï¿½rer les infos de tous nos produits (grï¿½ce ï¿½ model.php et sa fonction afficheAll()) et on les affiche via le concept render() (temporisation puis affichage)


4/Rï¿½-ï¿½criture de index.php

 -> A ce stade, nous avons plus besoin des routes ï¿½crutes dans index.php, mais on a besoin de require notre fichier de routes (routes.php)
 -> O ajoute le mode debug car nous sommes en dev.

Test: www.boutique.dev
<<<<<<< HEAD
A ce stade, npus devrions avoir la boutique qui s'affiche sur la home de notre nouveau site.
en revanche, nous sommes en procï¿½dural... Il va donc falloir ajouter une couche OBJET.
=======
A ce stade, npus devrions avoir la boutique qui s'affiche sur la home de notre nouveau site. 
en revanche, nous sommes en procédural... Il va donc falloir ajouter une couche OBJET. 



ETAPE 7 : UTILISATION DES SERVICES SILEX: 
Doctrine BDAL + modélisation objet 


Sommaire : 
1/Création de la classe Produit dans src/Entity 
2/Remplacement de PDO par Doctrine DBAL 
3/Créer le dossier DAO (Data Access Object)
4/Ajouter le fichier ProduitDAO.php 
5/Mise à jour de l'application via composer
6/Création du fichier app.php dans app/ 
7/creation du fichier prod.php dans app/config 
8/creation du fichier dev.php dans app/config/
9/Modification des routes
10/Modification de la vue 
11/Modification de l'index.php




1/ Création de la class Produit dans src/Entity 
->Creation de la classe Produit dans src/Entity/Produit.php 
->cette classe va servir de plan de fabrication d'un objet Produit. Un prototype. Il contient toutes les propriétés de l'entité produit (private) 
et tous les getter/setters. On dit que cette classe est un POPO (PLAIN OLD PHP OBJECT)


2/ Remplacement de PDO par Doctrine DBAL 
-> Doctrine DBAL (DATABASE Abstract Layer) : Fait la même chose que PDO mais améliore le système de requête. Ce service de Silex,, nous permet également une connexion compatible avec tout type de gestion de BDD.
Il nous récupère la connexion dans un SINGLETON sans qu'on ait besoin de le faire nous-même. 



3/ Création un dossier DAO dans src/

->DAO : DATA ACCESS OBJECT : DAO est un design pattern qui répond à la questioin ; Comment récupérer des infos depuis la base données non pas sous forme d'array, mais sous forme d'objets ? ==> voire la méthode (buildProduit())


4/Création du fichier produit DAO.php dans src/DAO/

-> Ce fichir correspond à notre MODEL PRODUIT. C'est lui qui va gérer toutes les requetes auprès de la table produit, et nous renvoyer les résultats sous forme d'objets. 

-> On a récupéré la connexion à la base de données grâce à Doctrine\DBAL\Connextion. 
->On stocke cette connexion dans la propriété private $db. 
->Chauqe requete sur la table Produit sera representee par une fonction. (findAll, findById, findAllByCategorie,etc...)
->Pour chacune de ses requestes quand cela est possible on va transformer les relustas d'array en objets grace à a la méthode buildProduit()).

===>DAO est un design pattern qui permet de modéliser sous forme d'objet (ENTITY) les resultats d'une requete.

Mise à jour de notre notre application 

 {
        "require": {
            "silex/silex": "~2.0",
            "doctrine/dbal": "2.5"
        }
        "autoload": {
            "psr-4" : {"BOUTIQUE\\": "src"}
        }
    }


<cmd>
composer update 

-> Cette commande a fait : 
- Récuperer les composants Doctrine DBAL
-Mise à jour l'autoload selon la norme PSR-4 (les noms des namespaces correspondent à des noms des dossiers) 


6/creation du fichier app.php dans le dossier app/ 
 ->Ce fichier représente les paramètres de notre application. Quand vous déplacerez votre application d'un server à un autre en théorie vous ne dervez modifier que ce fichier là... A l'insatr de init.inc.php dans notre procédural. 
 -> Les deux premieres lignes (use ErrorHandler et ExceptionHandler) permettent à notre application de gérer les erreurs sous forme d'Exception. 
Les composants Symfony prennent la main sur la gestion des erreurs PHP.


 -> Ensuite on enregistre le fournisseur de service associé à Doctrine DBAL. 
A faire pour tous les services utilisés.

-> Enfin on déclare/enregistre notre class ProduitDAO dans notre $app['dao.produit']. Cela nous permettra de rendre plus simple l'utilisation de notre instance de la classe ProduitDAO. 
$app['db'] représente par ailleurs notre connexion à la BDD grace à Doctrine DBAL. 


7/Création du fichier prod.php dans app/config 
-> Cefichier contient toutes les infos de connexion à la bdd. 

8/Création du fichier dev.php dans app/config
->Ce fichier contient les infos relatives à la phase de dev. 



9/modification du fichier routes.php 




10/Modification de view.php 
-> On remplace les arrays par l'utilisation des getter : 
ARRAY : <?= $pdt['titre'] ?>
OBJET : <?= $pdt->getTitre() ?>
TWIG : {{pdt.titre}}


11/Modification du fichier index.php 

->On met en commentaire $app['debug'] = true, puisque nous l'avons mis dans dev.php 
->On ajoute les require de app.php et dev.php avant le require de routes.php 

->A ce stade, notre home doit afficher tous les produits, et le menu des categories. 
===> Cette étape nous a permis d'introduire une modélisation objet (propre à silex : DAO, routing..) 
===> Nous avons beaucoup travaillé la partie MODELS (DAO) et CONTROLLER (Routes.php), à l'étape suivante nous allons inétresser à la partie VIEWS avec TWIIG

--------------------------------------------------------------------------
ETAPE 8: UTILISATION DES SERVICES SILEX(Twig)
(Ajout de l'utilisation de la fonction render)
--------------------------------------------------------------------------

Sommaire : 

1/ Intro 
2/Modification composer.json 
3/Mise à jour via comoposer 
4/Modification de app.php (enregistrement des nouveaux services)
5/Modification des fichiers view.php, produit.php en Twig 
6/Fonction render(): modélisation des routes. 
------------------------------

1/ Intro : 
-> Il existe plusieurs moteurs template : Liquid, TPL, smarty, Blade, Twig. 
-> De manière générale, un moteur de template permet de simplifier l'insertion de variables et de boucles PHP dans des blocs HTML.(idée des formes contractées) 

-> TWIG à l'avantage de proposer un systèùe d'héritage. En d'autres termes, des morceaux d'HTML vont hériter d'autres morceaux d'HTML. Exemple: Le formulaire d'inscription hérite du template général de la page. 

2/Modification du JSON 


3/Mise à jour via composer
<cmd>
composer update 


4/Modification de app.php 

->enregistrement aux services Twig. 
->L'enregistrement nécessite qu'on passe en argument le chemin de nos vues

<code>
 $app->register (new Silex/Provider/TwigServiceProvider(), array(
'twig.path' => __DIR__.'/../views'
)); 


5/Modifications de nos vues : 
-> view.php ==> index.html.twig
->produit.php===> produit.html.twig

6/ Modification des routes 
->Ajout de la méthode render() 

-----> A ce stade, notre home doit s'afficher. Test: www.boutique.dev. 
------> En savoir plus sur Twig





Exercice 
boutique/tshirt
boutique/chemise
boutique/pull

1/Créer la nouvelle route dans routes.php 
2/Créer la requete dans une fonction findByCategorie($categorie) dans ProduitDAO
3/Récupérer les infos de la fonction dans la route dans une varibale $produits 
...
5/Affiche la views view.php 
6/Modifier les liens des categories vers boutique/nom_de_la_categorie



>>>>>>> cfdec698788e459883f40334f2d88eeaffcd41c4
