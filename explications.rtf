{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf100
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 LucidaGrande;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww12600\viewh7800\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 ---------\
SILEX :\
------------------\
Sommaire :\
INTRO : Qu'est-ce que Silex ?\
Etape 0 : Base de notre app : site_mvc (proc
\f1 \uc0\u65533 
\f0 dural)\
ETAPE 1 : Installation de Silex\
ETAPE 2 : D
\f1 \uc0\u65533 
\f0 marrage et compr
\f1 \uc0\u65533 
\f0 hension\
ETAPE 3 : Le routing avec Silex\
ETAPE 4 : Virtual Host\
ETAPE 5 : HTACCESS : "On retire 'index.php'\
ETAPE 6 : D
\f1 \uc0\u65533 
\f0 marrage de notre application BOUTIQUE\
ETAPE 7 : Utilisation des services Silex (Doctine DBAL)\
ETAPE 8 : Utilisation des services Silex(Twig)\
ETPAE 9 : Utilisation des services Silex (Bootstrap)\
ETPAE 10: Ajout des commentaires 
\f1 \uc0\u65533 
\f0  nos produits (Injection de d
\f1 \uc0\u65533 
\f0 pendance)\
ETAPE 11: Le class DAO(design pattern : comment transformer un tableau multidimensionnel compos
\f1 \uc0\u65533 
\f0  d'array, en un tableau dimensionnel compos
\f1 \uc0\u65533 
\f0  d'objet)\
ETAPE 12 : H
\f1 \uc0\u65533 
\f0 ritage TWIG\
ETAPE 13: Gestion de la s
\f1 \uc0\u65533 
\f0 curit
\f1 \uc0\u65533 
\f0  (Connexion)\
ETAPE 14: Class MembreDAO et UserProviderInterface\
ETAPE 15: Formulaire de connexion\
ETAPE 16: Formulaire d'inscription\
ETPAE 17: Formulaire de contact\
ETAPE 18: BACKOFFICE\
ETAPE 19: R
\f1 \uc0\u65533 
\f0 organisation en Controller\
ETAPE 20: Prp
\f1 \uc0\u65533 
\f0 paration de la pise en prod.\
\
\
---------------------------------\
INTRO : Qu'est-ce que Silex ?\
\
\
  1/ Avantages 
\f1 \uc0\u65533 
\f0  utiliser un Framework ?\
\
   A/ Choix d'une organisation optimis
\f1 \uc0\u65533 
\f0 e. Il est tr
\f1 \uc0\u65533 
\f0 s difficile de conceptualiser soi-m
\f1 \uc0\u65533 
\f0 me une application en objet (un Framework maison). O
\f1 \uc0\u65533 
\f0  vont les controller? Les models? Les vues ? Aucune r
\f1 \uc0\u65533 
\f0 ponse n'est parfaite mais chacun 
\f1 \uc0\u65533 
\f0  sa propre organisation coh
\f1 \uc0\u65533 
\f0 rente...ou pas.\
\
\
  B/ Focntinnalit
\f1 \uc0\u65533 
\f0 s communes : Un framework permet de r
\f1 \uc0\u65533 
\f0 cup
\f1 \uc0\u65533 
\f0 rer des briques d
\f1 \uc0\u65533 
\f0 j
\f1 \uc0\u65533 
\f0  existantes.. et les r
\f1 \uc0\u65533 
\f0 cup
\f1 \uc0\u65533 
\f0 rer du site A vers le site B etc.. (Briques : Connexion, inscription, session, commentaires..)\
\
\
   C/ Services disponibles : Tous les frameworks proposent des services : Routage (Routing), la s
\f1 \uc0\u65533 
\f0 curit
\f1 \uc0\u65533 
\f0 , la gestion du cache etc...\
Cela nous permet de nous concentrer et de passer plus de temps au d
\f1 \uc0\u65533 
\f0 veloppement de nos propres fonctionnalit
\f1 \uc0\u65533 
\f0 s.\
\
\
\
   2/ Quel choix de Framework ?\
\
  A/Son propre framework maison ?\
Tr
\f1 \uc0\u65533 
\f0 s formateur !!On peut toujours l'am
\f1 \uc0\u65533 
\f0 liorer et l'utiliser dans des projets persos... par contre : pas de communaut
\f1 \uc0\u65533 
\f0 , pas de documentation et c'est difficile de grantir tous les aspects de s
\f1 \uc0\u65533 
\f0 curit
\f1 \uc0\u65533 
\f0 .\
\
\
\
  B/Framework du march
\f1 \uc0\u65533 
\f0  :\
\
-Framework Fullstack (Zend, Symfony, Cake) : Beaucoup de services disponibles, grosses communaut
\f1 \uc0\u65533 
\f0 s, mais un d
\f1 \uc0\u65533 
\f0 ploiement tr
\f1 \uc0\u65533 
\f0 s lourd et une architecture IMPOSEE.\
\
-Mini Framework (Laravel et Silex) : Proposent des services 
\f1 \uc0\u65533 
\f0  la carte et une architecture plus souple.\
\
 A/ Silex est un framework developp
\f1 \uc0\u65533 
\f0  par les 
\f1 \uc0\u65533 
\f0 quipes SensioLabs, qui sont les cr
\f1 \uc0\u65533 
\f0 ateurs de Symfony. Il repose sur les m
\f1 \uc0\u65533 
\f0 mes composants.\
\
\
\
 B/On dit que Silex est un mini-framework , parfait pour l'apprentissage, et la compr
\f1 \uc0\u65533 
\f0 hension de la logique Framework. Parfait 
\f1 \uc0\u65533 
\f0 galement pour d
\f1 \uc0\u65533 
\f0 velopper des applications rapidement et premi
\f1 \uc0\u65533 
\f0 re 
\f1 \uc0\u65533 
\f0 tape int
\f1 \uc0\u65533 
\f0 ressante dans l'apprentissage de Symfony.\
\
\
\
\
\
\
  B/Framework du march
\f1 \uc0\u65533 
\f0  : FullStack\
\
\
\
\
\
\
----------------------------------------------------\
Etapae 0 : Base de notre app : site_mvc (proc
\f1 \uc0\u65533 
\f0 dural)\
----------------------------------------------------\
Pour commencer la compr
\f1 \uc0\u65533 
\f0 hension de Silex, nous allons partir sur la base d'un morceau de site en proc
\f1 \uc0\u65533 
\f0 dural et en MVC afin d'avancer 
\f1 \uc0\u65533 
\f0 tape par 
\f1 \uc0\u65533 
\f0 tape :\
\
\
silex/site_mvc/\
    - css/(copier de votre ancien site proc
\f1 \uc0\u65533 
\f0 dural)\
    - photo/(copier de votre ancien site proc
\f1 \uc0\u65533 
\f0 dural)\
    - index.php (vide)\
    - model.php(vide)\
    - view.php (vide)\
\
\
\
\
Etape 1 : Installation de Silex\
\
\
\
Sommaire:\
\
1/Installation de composer\
2/Cr
\f1 \uc0\u65533 
\f0 ation du dossier BOUTIQUE\
3/ Commande pour t
\f1 \uc0\u65533 
\f0 l
\f1 \uc0\u65533 
\f0 charger les composants de Silex\
3.Bis : Autre technique pour t
\f1 \uc0\u65533 
\f0 l
\f1 \uc0\u65533 
\f0 charger les composants de silex\
4/ tour d'horizon des composants.\
-------------------------\
\
\
\
1/Installation de Composer\
\
Composer est outil de gestion des d
\f1 \uc0\u65533 
\f0 pendances. Il permet d'installer des services (composants, d
\f1 \uc0\u65533 
\f0 pendances) et est reli
\f1 \uc0\u65533 
\f0  
\f1 \uc0\u65533 
\f0  un fichier composer.json.\
\
-->T
\f1 \uc0\u65533 
\f0 l
\f1 \uc0\u65533 
\f0 charger composer\
--> Installer composer (en pr
\f1 \uc0\u65533 
\f0 cisant php.exe)\
\
\
2/ creation du dossier silex/BOUTIQUE/\
\
3/ cOMMANDE POUR T2L2CHARGER LES COMPOSANTS DE SILEX /\
-> on se place dans le dossier BOUTIQUE/\
-> Maj + clic droit > "Ouvrir la fenetre de commande ici"\
\
\
<cmd>\
\
composer require silex/silex "~2.0"\
  <code>\
    \{\
     "require": \{\
                "silex/silex": "~2.0"\
                \}\
        \}\
      <cmd>\
  composer update\
\
\
4/Les composants :\
\
Le dossier vendor correspond au coeur de notre framework. Il contient tous les composants r
\f1 \uc0\u65533 
\f0 cup
\f1 \uc0\u65533 
\f0 r
\f1 \uc0\u65533 
\f0 s de Silex/Symfony, sur lesquels nous n'intervidendrons jamais !!!\
\
3.bis\
\
----------------------------\
ETAPE 2 : D
\f1 \uc0\u65533 
\f0 marrage et Compr
\f1 \uc0\u65533 
\f0 hension\
------------------------------\
\
Sommaire :\
1/Cr
\f1 \uc0\u65533 
\f0 ation du r
\f1 \uc0\u65533 
\f0 pertoire Web\
2/Cr
\f1 \uc0\u65533 
\f0 ation du fichier index.php\
\
\
1/repertoire web\
\
-> a la racine de notre application BOUTIQUE/web/\
-> Ce dossier constitue notre repertoire web, cela signifie qu'il va contenir tout ce qui est visble et accessible pour l'internaute (index.php, photos, img, fonts, js, css...)\
\
\
2/ creer web/index.php\
\
->d'abord on require l'autoload qui se chargera de require tous les fichiers dont on aura besoin.PRATIQUE !\
\
\
\
-> On instancie la classe Application : L'objet $app va repr
\f1 \uc0\u65533 
\f0 senter notre application et nous donne acc
\f1 \uc0\u65533 
\f0 s 
\f1 \uc0\u65533 
\f0  toutes les fonctionnalit
\f1 \uc0\u65533 
\f0 s de Silex.\
\
-> M
\f1 \uc0\u65533 
\f0 thode run() : Lancement de l'application.\
\
\
\
---------------------------------\
ETAPE 3 : Le routing sur Silex\
--------------------------------\
\
Sommaire :\
\
1/ Route Hello World\
2/ Route Hello \{$name\}\
3/ La fonction Get de notre application\
4/ Arguments\
5/ fonction escape()\
-----------------------\
\
\
\
1/ Route Hello World\
\
\
 -> $app -> get() est la fonction qui nous permet de cr
\f1 \uc0\u65533 
\f0 er une nouvelle route. Chaque route est une action dans notre application. Ensuite nous rangerons toutes nos actions dans des controllers, pour optimiser notre organisation.\
\
\
2/Route Hello \{$name\}\
  ->Creation de la route /hello/\{name\}\
->Test : localhost/silex/BOUTIQUE/web/index.php/hello/Yannick\
\
\
3/La fonction Get()\
-> A chaque nouvelle fonctionnalit
\f1 \uc0\u65533 
\f0 , on va utiliser la fonction get de $app, qui nous cr
\f1 \uc0\u65533 
\f0 e une nouvelle route. En plus de get, il existe post() et match(). Nous les verrons plus tard.\
\
\
4/Arguments:\
-> le premier argument est la nom de la route. Les param
\f1 \uc0\u65533 
\f0 trres contenus dans les URL sont alors d
\f1 \uc0\u65533 
\f0 clar
\f1 \uc0\u65533 
\f0  en \{]\
-> le second argument function\{\} est ce que l'on appelle une "closure" ou une "fonction anonyme". Elle signifie que ce qui va suivre sera execut
\f1 \uc0\u65533 
\f0 . Une fonction dans une fontion finalement. Elle peut recevoir les param
\f1 \uc0\u65533 
\f0 trres dynamiques de notre URL (ex: function ($name)).\
\
5/ La m
\f1 \uc0\u65533 
\f0 thode escape()\
 -> La fonction escape() permet simplement d'afficher le param
\f1 \uc0\u65533 
\f0 tre contenu dans la route.La m
\f1 \uc0\u65533 
\f0 thode escape() permet d'
\f1 \uc0\u65533 
\f0 viter les injections SQL dans votre URL.\
\
-----------------------\
ETAPE 4 : VIRTUAL HOST\
------------------------\
\
Sommaire :\
\
1/ Modifier le fichier vhost (apache)\
2/ Modifier le fichier conf (apache)\
3/Modifier le fichier host (system32)\
\
\
\
1/mODIFICATION DU FICHIER VHOST /\
 >c:\\xampp\\apache\\conf\\extra\\httpd-vhosts.conf\
\
2/ Modification du fichier conf :\
> c:\\xampp\\apache\\conf\\httpd.conf\
\
3/ Modification du fichier Hosts dans system 32\
> c:\\windows\\system32\\drivers\\etc\\hosts\
\
\
\
\
\
-------------------------------------------\
ETAPE 5 : HTACCESS POUR RETIRER INDEX.PHP :\
-------------------------------------------\
\
 -> Cr
\f1 \uc0\u65533 
\f0 er dans le dossier web de notre application, test.txt\
\
\
 <code>\
    <IfModule mod_rewrite.c>\
\
   Options -MultivViews\
\
\
  RewriteEngine On\
\
  RewriteCond %\{REQUEST_FILENAME\} !-f\
\
  RewriteRule ^ index.php [QSA,L]\
\
  </IfModule>\
\
\
 -> Enregistrer le fichier avec l'extension .htaccess.\
Pour ce faire, selectionner tous les formats\
\
\
\
Test 
\f1 \uc0\u65533 
\f0  effectuer : www.boutique.dev/hello/yakine\
\
\
\
\
\
--------------------------------------\
ETAPE 6 : DEMARRAGE DE L'APPLICATION :\
--------------------------------------\
\
Sommaire :\
1/ Cr
\f1 \uc0\u65533 
\f0 ation des dossiers\
\
2/ R
\f1 \uc0\u65533 
\f0 cup
\f1 \uc0\u65533 
\f0 rer les fichiers (de notre base site_mvc)\
\
3/ Cr
\f1 \uc0\u65533 
\f0 ation du fichier de routes\
\
4/ R
\f1 \uc0\u65533 
\f0 -
\f1 \uc0\u65533 
\f0 criture de index.php\
\
--------------------------------------\
\
1/ Cr
\f1 \uc0\u65533 
\f0 ation des dossiers :\
\
 BOUTIQUE/\
\
  web/      (d
\f1 \uc0\u65533 
\f0 j
\f1 \uc0\u65533 
\f0  cr
\f1 \uc0\u65533 \u65533 
\f0 )\
\
  vendor/ (d
\f1 \uc0\u65533 
\f0 j
\f1 \uc0\u65533 
\f0  cr
\f1 \uc0\u65533 
\f0 e)\
\
    app/     (config de l'application)\
\
  db/     (script de creation de la bdd)\
\
   src/     (fichiers sources de notre application)\
\
 views/     (les vues de notre application)\
\
2/ R
\f1 \uc0\u65533 
\f0 cup
\f1 \uc0\u65533 
\f0 rer les fichiers (de notre base site_mvc)\
\
Dans un premier temps on va g
\f1 \uc0\u65533 
\f0 rer l'affichage de nos produits\
\
->model.php 
\f1 \uc0\u65533 
\f0  copier/coller dans src/\
->view.php 
\f1 \uc0\u65533 
\f0  copier/coller dans views/\
->css/photo/ 
\f1 \uc0\u65533 
\f0  copier/coller dans web/\
\
\
3/ Cr
\f1 \uc0\u65533 
\f0 er un fichier de route qui va contenir toutes nos routes\
 -> app/routes.php\
-> On re-cr
\f1 \uc0\u65533 
\f0 e ma route '/'(la home), dans laquelle on va r
\f1 \uc0\u65533 
\f0 cup
\f1 \uc0\u65533 
\f0 rer les infos de tous nos produits (gr
\f1 \uc0\u65533 
\f0 ce 
\f1 \uc0\u65533 
\f0  model.php et sa fonction afficheAll()) et on les affiche via le concept render() (temporisation puis affichage)\
\
\
4/R
\f1 \uc0\u65533 
\f0 -
\f1 \uc0\u65533 
\f0 criture de index.php\
\
 -> A ce stade, nous avons plus besoin des routes 
\f1 \uc0\u65533 
\f0 crutes dans index.php, mais on a besoin de require notre fichier de routes (routes.php)\
 -> O ajoute le mode debug car nous sommes en dev.\
\
Test: www.boutique.dev\
\
A ce stade, npus devrions avoir la boutique qui s'affiche sur la home de notre nouveau site.\
en revanche, nous sommes en proc
\f1 \uc0\u65533 
\f0 dural... Il va donc falloir ajouter une couche OBJET.\
=======\
A ce stade, npus devrions avoir la boutique qui s'affiche sur la home de notre nouveau site.\
en revanche, nous sommes en proc
\f1 \uc0\u65533 
\f0 dural... Il va donc falloir ajouter une couche OBJET.\
\
\
\
ETAPE 7 : UTILISATION DES SERVICES SILEX:\
Doctrine BDAL + mod
\f1 \uc0\u65533 
\f0 lisation objet\
\
\
Sommaire :\
1/Cr
\f1 \uc0\u65533 
\f0 ation de la classe Produit dans src/Entity\
2/Remplacement de PDO par Doctrine DBAL\
3/Cr
\f1 \uc0\u65533 
\f0 er le dossier DAO (Data Access Object)\
4/Ajouter le fichier ProduitDAO.php\
5/Mise 
\f1 \uc0\u65533 
\f0  jour de l'application via composer\
6/Cr
\f1 \uc0\u65533 
\f0 ation du fichier app.php dans app/\
7/creation du fichier prod.php dans app/config\
8/creation du fichier dev.php dans app/config/\
9/Modification des routes\
10/Modification de la vue\
11/Modification de l'index.php\
\
\
\
\
1/ Cr
\f1 \uc0\u65533 
\f0 ation de la class Produit dans src/Entity\
->Creation de la classe Produit dans src/Entity/Produit.php\
->cette classe va servir de plan de fabrication d'un objet Produit. Un prototype. Il contient toutes les propri
\f1 \uc0\u65533 
\f0 t
\f1 \uc0\u65533 
\f0 s de l'entit
\f1 \uc0\u65533 
\f0  produit (private)\
et tous les getter/setters. On dit que cette classe est un POPO (PLAIN OLD PHP OBJECT)\
\
\
2/ Remplacement de PDO par Doctrine DBAL\
-> Doctrine DBAL (DATABASE Abstract Layer) : Fait la m
\f1 \uc0\u65533 
\f0 me chose que PDO mais am
\f1 \uc0\u65533 
\f0 liore le syst
\f1 \uc0\u65533 
\f0 me de requ
\f1 \uc0\u65533 
\f0 te. Ce service de Silex,, nous permet 
\f1 \uc0\u65533 
\f0 galement une connexion compatible avec tout type de gestion de BDD.\
Il nous r
\f1 \uc0\u65533 
\f0 cup
\f1 \uc0\u65533 
\f0 re la connexion dans un SINGLETON sans qu'on ait besoin de le faire nous-m
\f1 \uc0\u65533 
\f0 me.\
\
\
\
3/ Cr
\f1 \uc0\u65533 
\f0 ation un dossier DAO dans src/\
\
->DAO : DATA ACCESS OBJECT : DAO est un design pattern qui r
\f1 \uc0\u65533 
\f0 pond 
\f1 \uc0\u65533 
\f0  la questioin ; Comment r
\f1 \uc0\u65533 
\f0 cup
\f1 \uc0\u65533 
\f0 rer des infos depuis la base donn
\f1 \uc0\u65533 
\f0 es non pas sous forme d'array, mais sous forme d'objets ? ==> voire la m
\f1 \uc0\u65533 
\f0 thode (buildProduit())\
\
\
4/Cr
\f1 \uc0\u65533 
\f0 ation du fichier produit DAO.php dans src/DAO/\
\
-> Ce fichir correspond 
\f1 \uc0\u65533 
\f0  notre MODEL PRODUIT. C'est lui qui va g
\f1 \uc0\u65533 
\f0 rer toutes les requetes aupr
\f1 \uc0\u65533 
\f0 s de la table produit, et nous renvoyer les r
\f1 \uc0\u65533 
\f0 sultats sous forme d'objets.\
\
-> On a r
\f1 \uc0\u65533 
\f0 cup
\f1 \uc0\u65533 
\f0 r
\f1 \uc0\u65533 
\f0  la connexion 
\f1 \uc0\u65533 
\f0  la base de donn
\f1 \uc0\u65533 
\f0 es gr
\f1 \uc0\u65533 
\f0 ce 
\f1 \uc0\u65533 
\f0  Doctrine\\DBAL\\Connextion.\
->On stocke cette connexion dans la propri
\f1 \uc0\u65533 
\f0 t
\f1 \uc0\u65533 
\f0  private $db.\
->Chauqe requete sur la table Produit sera representee par une fonction. (findAll, findById, findAllByCategorie,etc...)\
->Pour chacune de ses requestes quand cela est possible on va transformer les relustas d'array en objets grace 
\f1 \uc0\u65533 
\f0  a la m
\f1 \uc0\u65533 
\f0 thode buildProduit()).\
\
===>DAO est un design pattern qui permet de mod
\f1 \uc0\u65533 
\f0 liser sous forme d'objet (ENTITY) les resultats d'une requete.\
\
Mise 
\f1 \uc0\u65533 
\f0  jour de notre notre application\
\
 \{\
        "require": \{\
            "silex/silex": "~2.0",\
            "doctrine/dbal": "2.5"\
        \}\
        "autoload": \{\
            "psr-4" : \{"BOUTIQUE\\\\": "src"\}\
        \}\
    \}\
\
\
<cmd>\
composer update\
\
-> Cette commande a fait :\
- R
\f1 \uc0\u65533 
\f0 cuperer les composants Doctrine DBAL\
-Mise 
\f1 \uc0\u65533 
\f0  jour l'autoload selon la norme PSR-4 (les noms des namespaces correspondent 
\f1 \uc0\u65533 
\f0  des noms des dossiers)\
\
\
6/creation du fichier app.php dans le dossier app/\
 ->Ce fichier repr
\f1 \uc0\u65533 
\f0 sente les param
\f1 \uc0\u65533 
\f0 tres de notre application. Quand vous d
\f1 \uc0\u65533 
\f0 placerez votre application d'un server 
\f1 \uc0\u65533 
\f0  un autre en th
\f1 \uc0\u65533 
\f0 orie vous ne dervez modifier que ce fichier l
\f1 \uc0\u65533 
\f0 ... A l'insatr de init.inc.php dans notre proc
\f1 \uc0\u65533 
\f0 dural.\
 -> Les deux premieres lignes (use ErrorHandler et ExceptionHandler) permettent 
\f1 \uc0\u65533 
\f0  notre application de g
\f1 \uc0\u65533 
\f0 rer les erreurs sous forme d'Exception.\
Les composants Symfony prennent la main sur la gestion des erreurs PHP.\
\
\
 -> Ensuite on enregistre le fournisseur de service associ
\f1 \uc0\u65533 
\f0  
\f1 \uc0\u65533 
\f0  Doctrine DBAL.\
A faire pour tous les services utilis
\f1 \uc0\u65533 
\f0 s.\
\
-> Enfin on d
\f1 \uc0\u65533 
\f0 clare/enregistre notre class ProduitDAO dans notre $app['dao.produit']. Cela nous permettra de rendre plus simple l'utilisation de notre instance de la classe ProduitDAO.\
$app['db'] repr
\f1 \uc0\u65533 
\f0 sente par ailleurs notre connexion 
\f1 \uc0\u65533 
\f0  la BDD grace 
\f1 \uc0\u65533 
\f0  Doctrine DBAL.\
\
\
7/Cr
\f1 \uc0\u65533 
\f0 ation du fichier prod.php dans app/config\
-> Cefichier contient toutes les infos de connexion 
\f1 \uc0\u65533 
\f0  la bdd.\
\
8/Cr
\f1 \uc0\u65533 
\f0 ation du fichier dev.php dans app/config\
->Ce fichier contient les infos relatives 
\f1 \uc0\u65533 
\f0  la phase de dev.\
\
9/Modification du fichier routes.php\
-> On remplace l'ancien require model.php qui nous permettait d'acc
\f1 \uc0\u65533 
\f0 der 
\f1 \uc0\u65533 
\f0  la m
\f1 \uc0\u65533 
\f0 thode afficheAll() par une instanciation de ProduitDAO($app['produitDAO'])qui est notre nouveau model. Dans ce nouveau model, on 
\f1 \uc0\u65533 
\f0 x
\f1 \uc0\u65533 
\f0 cute findAll() et findAlCategories.\
===> La logique Controller/Model reste la m
\f1 \uc0\u65533 
\f0 me qu'auparavant.\
\
/!\\ Attention : Dans notre vue view.php, nous utilisons des arrays ($produit['titre']) mais maintenant on doit utiliser des objets ($produit->getTitre()).\
\
\
\
10/ Modification de view.php\
-> on remplace les arrays par l'utilisation des getter :\
ARRAY : <?= $pdt['titre'] ?>\
OBJET : <?=$pdt->getTitre() ?>\
TWIG : \{\{ pdt.titre\}\}\
\
>>>>>>> cfdec698788e459883f40334f2d88eeaffcd41c4\
}